#!/usr/bin/env python

import argparse
import os
import random
import string
import subprocess
from pathlib import Path
from subprocess import CompletedProcess
from typing import List, Tuple, Optional, Union

Parser = Union[argparse.ArgumentParser, argparse._MutuallyExclusiveGroup, argparse._ArgumentGroup]  # noqa
Arguments = List[Tuple[list, dict]]


def make_dir(dir_path: Path) -> Path:
    dir_path.mkdir(parents=True, exist_ok=True)
    return dir_path


# Paths
path: Path = Path(__file__).resolve().parent.parent.resolve()
build_dir: Path = make_dir(path / "build")
temp_dir: Path = make_dir(path / "temp")
coverage_dir: Path = make_dir(build_dir / "coverage")
junit_dir: Path = make_dir(build_dir / f"junit")
cucumber_dir: Path = make_dir(build_dir / f"cucumber")


def run_command(cwd: Path, cmd: str) -> CompletedProcess:
    cmd_env = os.environ.copy()
    print(f"command: {cmd}")
    completed_process = subprocess.run(cmd, cwd=cwd, shell=True, env=cmd_env)
    return completed_process


generated_random_string: bool = False


def get_random_alphanumeric_string(length: int) -> str:
    letters_and_digits = string.ascii_letters + string.digits
    result_str = ''.join((random.choice(letters_and_digits) for _ in range(length)))
    print(f"Random alphanumeric String is: {result_str}")
    global generated_random_string
    generated_random_string = True
    return result_str


def report_coverage() -> None:
    result = run_command(path, f"coverage combine {coverage_dir}/")
    assert result.returncode == 0
    result = run_command(path, f"coverage report xml -o {coverage_dir}/xml")
    assert result.returncode == 0
    result = run_command(path, f"coverage report html --directory {coverage_dir}/html")
    assert result.returncode == 0
    result = run_command(path, f"coverage report json -o {coverage_dir}/json")
    assert result.returncode == 0
    exit()


def test(command_options: str, label: Optional[str] = None) -> None:
    file_label = "" if label is None else f".{label}"

    # Base command
    command = f"pytest --basetemp={temp_dir} -vv"

    # Add extra arguments
    command += command_options

    # Coverage command
    command += " --cov-config=.coveragerc --cov-append --cov=clowder"

    # Coverage reports
    xml_file = coverage_dir / f"coverage{file_label}.xml"
    command += f" --cov-report xml:{xml_file}"
    html_dir = coverage_dir / f"html{file_label}"
    command += f" --cov-report html:{html_dir}"
    annotate_dir = coverage_dir / f"annotate{file_label}"
    command += f" --cov-report annotate:{annotate_dir}"

    # JUnit reports
    junit_file = junit_dir / f"results{file_label}.xml"
    command += f" --junitxml={junit_file}"

    # BDD reports
    cucumber_file = cucumber_dir / f"results{file_label}.json"
    bdd_reporting_options = f" --cucumberjson={cucumber_file} --cucumberjson-expanded"
    command += bdd_reporting_options

    # Run command
    result = run_command(path, command)

    # Rename coverage
    if file_label:
        old_coverage_file = coverage_dir / ".coverage"
        new_coverage_file = coverage_dir / f".coverage{file_label}"
        old_coverage_file.rename(new_coverage_file)

    if result.returncode != 0:
        exit(result.returncode)


def add_parser_arguments(parser: Parser, arguments: Arguments) -> None:
    for argument in arguments:
        parser.add_argument(*argument[0], **argument[1])


def main() -> None:
    try:
        parser = argparse.ArgumentParser()
        arguments = [
            (['--groups'], dict(metavar='<n>', nargs=1, default=None, type=int,
                                help='number of groups to split tests into')),
            (['--group', "-g"], dict(metavar='<n>', nargs=1, default=None, type=int,
                                     help='number of groups to split tests into')),
            (['--label', '-l'], dict(nargs=1, metavar='<label>', default=None,
                                     help='label to append to results')),
            (['--parallel', '-p'], dict(action='store_true', help='run tests in parallel'))
        ]
        add_parser_arguments(parser, arguments)

        group = parser.add_mutually_exclusive_group(required=True)
        mutually_exclusive_arguments = [
            (['--report-coverage', '-r'], dict(action='store_true', help='generate test coverage reports')),
            (['--markers', '-m'], dict(nargs=1, metavar='<markers>', help='test markers to run'))
        ]
        add_parser_arguments(group, mutually_exclusive_arguments)
        args = parser.parse_args()

        if args.report_coverage:
            report_coverage()
            exit()

        options = f" -m '{args.markers[0]}'"

        if args.parallel:
            options += " -n auto"

        if args.groups and args.group:
            options += f" --test-group-count {args.groups[0]} --test-group={args.group[0]}"
        elif args.group or args.groups:
            print("--groups and --group are both required if one is used")
            exit(1)

        test(options, None if args.label is None else args.label[0])

    except Exception as err:
        print(err)
        exit(1)


if __name__ == '__main__':
    main()
