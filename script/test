#!/usr/bin/env python

import argparse
import os
import random
import string
import subprocess
from pathlib import Path
from subprocess import CompletedProcess
from typing import List, Tuple, Union

Parser = Union[argparse.ArgumentParser, argparse._MutuallyExclusiveGroup, argparse._ArgumentGroup]  # noqa
Arguments = List[Tuple[list, dict]]

# Repo path
path = Path(__file__).resolve().parent.parent.resolve()

# Create build dirs
build_dir = path / "build"
build_dir.mkdir(parents=True, exist_ok=True)
coverage_dir = build_dir / "coverage"
coverage_dir.mkdir(parents=True, exist_ok=True)
temp_dir = path / "temp"
temp_dir.mkdir(parents=True, exist_ok=True)


def run_command(cwd: Path, cmd: str) -> CompletedProcess:
    cmd_env = os.environ.copy()
    print(f"TEST: {cmd}")
    completed_process = subprocess.run(cmd, cwd=cwd, shell=True, env=cmd_env)
    return completed_process


def get_random_alphanumeric_string(length: int) -> str:
    letters_and_digits = string.ascii_letters + string.digits
    result_str = ''.join((random.choice(letters_and_digits) for _ in range(length)))
    print(f"Random alphanumeric String is: {result_str}")
    return result_str


def report() -> None:
    # Coverage reports
    result = run_command(path, f"coverage combine {coverage_dir}")
    assert result.returncode == 0
    result = run_command(path, f"coverage report xml -o {coverage_dir}/xml")
    assert result.returncode == 0
    result = run_command(path, f"coverage report html --directory {coverage_dir}/html")
    assert result.returncode == 0
    result = run_command(path, f"coverage report json -o {coverage_dir}/json")
    assert result.returncode == 0
    exit()


def test(label: str, options: str) -> None:
    # Base command
    command = f"pytest --basetemp={temp_dir} -vv"
    # Coverage command
    command += " --cov-config=.coveragerc --cov-append --cov=clowder"
    # Add extra arguments
    command += options

    # JUnit reports
    junit_dir = build_dir / f"junit"
    junit_dir.mkdir(parents=True, exist_ok=True)
    junit_file = junit_dir / f"results.{label}.xml"
    command += f" --junitxml={junit_file}"

    # BDD reports
    cucumber_dir = build_dir / f"cucumber"
    cucumber_dir.mkdir(parents=True, exist_ok=True)
    cucumber_file = cucumber_dir / f"results.{label}.json"
    bdd_reporting_options = f" --cucumberjson={cucumber_file} --cucumberjson-expanded"
    command += bdd_reporting_options

    # Run command
    result = run_command(path, command)

    # Rename coverage
    old_coverage_file = coverage_dir / ".coverage"
    new_coverage_file = coverage_dir / f".coverage.{label}"
    old_coverage_file.rename(new_coverage_file)

    if result.returncode != 0:
        exit(result.returncode)


def add_parser_arguments(parser: Parser, arguments: Arguments) -> None:
    for argument in arguments:
        parser.add_argument(*argument[0], **argument[1])


def main() -> None:
    try:
        parser = argparse.ArgumentParser()
        arguments = [
            (['--groups'], dict(metavar='<n>', nargs=1, default=None, type=int,
                                help='number of groups to split tests into')),
            (['--group', "-g"], dict(metavar='<n>', nargs=1, default=None, type=int,
                                     help='number of groups to split tests into')),
            (['--label', '-l'], dict(nargs=1, metavar='<label>', default=get_random_alphanumeric_string(12),
                                     help='label to append to results')),
            (['--parallel', '-p'], dict(action='store_true', help='run tests in parallel'))
        ]
        add_parser_arguments(parser, arguments)

        group = parser.add_mutually_exclusive_group(required=True)
        mutually_exclusive_arguments = [
            (['--report', '-r'], dict(action='store_true', help='generate test reports')),
            (['--markers', '-m'], dict(nargs=1, metavar='<markers>', help='test markers to run'))
        ]
        add_parser_arguments(group, mutually_exclusive_arguments)
        args = parser.parse_args()

        if args.report:
            report()
            exit()

        options = f" -m '{args.markers[0]}'"
        if args.parallel:
            options += " -n auto"
        if args.groups or args.group:
            options += f" --test-group-count {args.groups[0]} --test-group={args.group[0]}"

        test(args.label[0], options)
    except Exception as err:
        print(err)
        exit(1)


if __name__ == '__main__':
    main()
